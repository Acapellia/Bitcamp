--<트랜잭션이란?>
--; 트랜잭션은 반드시 함께 실행되어야 하는 작업의 단위를 의미한다.
--즉 사용자의 의도에 따라 여러 개의 문장으로 구성된 트랜잭션은 반드시 
--동시에 실행(COMMIT)되거나 취소(ROLLBACK)된다.
--RDBMS는 트랜잭션을 통해 작업의 단위를 결정함으로써 작업 결과의 신뢰성을
--확보한다.
--
--예를 들어 금융 거래 중에 계좌 이체를 생각해보자. 
--A라는 사람이 소유 계좌의 금액 중 100만원을 B라는 사람의 계좌로 이체한다면
--최소 두 가지 작업이 수행돼야 한다.
--1번째 작업은 A의 계좌에서 100만원이 출금되는 것이다.
--2번째 작업은 B의 계좌에 100만원이 입금되는 것이다
--
--그런데, 만약 A의 계좌에서 100만원이 출금된 이후 2번째 작업이 수행되기 전에
--시스템이 다운된다면 B의 계좌에 돈이 입금되지 않고 A의 계좌에서만 100만원만
--없어지게 될 수도 있다.
-- 이런 문제를 방지하기 위해 두 개의 작업을 하나의 트랜잭션으로 묶어 놓으면
--두 개의 작업이 모두 실행되지 않으면 모두 취소됨으로 거래의 신뢰도를 높일 수 
--있다. 
--즉, 두 번째 작업인 입금이 실행되지 않으면 첫 번째 출금 작업은 자동으로
--취소되도록 함으로써 거래의 신뢰성을 확보하는 것이다.
--
--1) 트랜잭션의 시작과 종료
--1-1) 시작
--이전 트랜잭션이 종료된 이후 dml(insert, update, delete) 문장이나
--ddl(create, alter,drop,truncate),
--dcl(grant,revoke) 문장이 실행됐을 때 시작된다.
--1-2) 종료
--a) commit이나 rollback 명령이 실행될 때 종료된다.
--b) ddl이나 dcl 문장의 실행이 완료되면 자동으로 종료된다.
--c) 사용자의 정상 종료 시에 종료된다.
--d) dead lock이 걸리면 트랜잭션의 일부만 종료된다.

1-3) 기타
트랜잭션은 하나의 session에서 단지 하나만 시작할 수 있다.
dml의 경우 반드시 commit이나 rollback으로 종료한다.
ddl이나 dcl의 경우 문장이 실행되고 난 후 자동으로 죵료된다.
오라클은 save point 명령을 이용해서 트랜잭션의 중간 과정을 저장해두고 복원할 수 있다.

2) 트랜잭션과 언두 세그먼트(Undo Segment)
dml 작업을 rollback 하기 위해서는 작업 이전 데이터를 어딘가에 저장해 두어야한다.
오라클은 작업이 발생하면 즉시 테이블의 내용을 변경하기 때문에 delete나 update문을 실행하면 테이블의 정보가 즉시 변경된다.
그러나 사용자가 rollback을 실행하면 dml 작업에 의해서 변경된 정보를 이전 정보로 환원해야 하는데 만일 작업 이전 정보를 저장하고 있지 않다면 rollback을 실행할 수 없다.
이렇게 작업 이전 정보를 저장하고 관리하는 것은 트랜잭션의 기본 기능이며 이를 위해서 오라클은 언두 테이블스페이스와 언두 세그먼트라는 물리적인 구조를 이용한다.
이들은 자동으로 관리되며 사용자는 이들 정보를 직접 볼 수 없으며 단지 트랜잭션에서만 사용된다.

<요약>
  Oracle : DML 명령 -> 테이블 정보 변경
                      언두 세그먼트에 이전 테이블 정보 저장
                    -> COMMIT 
                      테이블 정보 확정
                      언두 세그먼트 이전 테이블 정보 삭제
  SQL-Server : DML 명령 -> 테이블 정보 미변경
                        명령에 의한 새로운 정보를 별도의 공간에 저장
                    -> COMMIT
                       테이블 정보 변경 확정

3) 트랜잭션 과정
오라클은 INSERT(UPDATE,DELETE) 문이 실행될 때 행이 입력된다
그리고 입력된 행에만 잠금이 걸린다(독점 잠금)
COMMIT 시 잠금이 풀린다

ex) 테이블의 데이터 5를 7로 UPDATE 하는 과정
1) UPDATE 문장이 테이블에 발생하면, 문장 수행을 위해 사용할
  UNDO SEGMENT 를 결정한다.
2) 테이블에 저장되어있던 원래 값(5)를 UNDO SEGMENT 에 저장한다
3) UPDATE 된 값(7)이 테이블에 저장된다
4) 값이 변경된 행은 독점 잠금(Exclusive Lock)이 발생된다.
5) 해당 행이 존재하는 테이블은 공유 잠금(Share Lock)이 발생된다.
6) 트랜잭션이 COMMIT 되면 잠금은 모두 해제되고 변경된 값(7)은
  영구히 저장된다.
7) 트랜잭션이 ROLLBACK 되면 UNDO SEGMENT 에 저장했던 원래 값(5)를
  테이블로 환원하고 잠금이 해제된다.
  
<독점 잠금(Exclusive Lock)과 공유 잠금(Share Lock)>
1) 독점 잠금 : 다른 세션의 접근을 불허한다.
             다른 세션은 해당 행을 검색할 수 없고,
             UNDO SEGMENT 에 있는 정보만 보게 된다.
2) 공유 잠금 : DDL(Alter, Drop) 작업을 방지한다.
































